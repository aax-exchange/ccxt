# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadResponse
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import OrderNotFound
from ccxt.base.decimal_to_precision import ROUND


class aax(Exchange):

    def describe(self):
        return self.deep_extend(super(aax, self).describe(), {
            'id': 'aax',
            'name': 'AAX',
            'countries': ['MT'],
            'enableRateLimit': True,
            'rateLimit': 1000,
            'version': 'v2',
            'v1': 'marketdata/v1',
            'has': {
                'cancelAllOrders': True,
                'createLimitOrder': False,
                'createMarketOrder': False,
                'cancelOrder': True,
                'createOrder': True,
                'editOrder': True,
                'fetchBalance': True,
                'fetchClosedOrders': True,
                'fetchDepositAddress': False,
                'fetchMarkets': True,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrders': True,
                'fetchOrderBook': True,
                'fetchOrderTrades': False,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTrades': True,
            },
            'timeframes': {
                '1m': '1',
                '5m': '5',
                '15m': '15',
                '30m': '30',
                '1h': '60',
                '2h': '120',
                '4h': '240',
                '12h': '720',
                '1d': '1440',
                '3d': '4320',
                '1w': '10080',
            },
            'urls': {
                'logo': 'http://cdn.aaxvip.com/res/images/logo/AAX-25B.jpg',
                'api': 'https://api.aaxpro.com',
                'www': 'https://www.aaxpro.com',  # string website URL
                'doc': 'https://www.aaxpro.com/apidoc/index.html',
            },
            'api': {
                'public': {
                    'get': [
                        'instruments',  # This endpoint is used to retrieve all instruments information.
                        'market/candles',  # Get OHLC(k line) of specific market
                        'getHistMarketData',  # Get OHLC(k line) of specific market v1
                        'market/orderbook',  # This endpoint allows you to retrieve the current order book for a specific symbol.
                        'market/tickers',  # This endpoint allows you to retrieve the trading summary for all symbol in the last 24 hours
                        'market/trades',  # Get the Most Recent Trades
                        'order_book',  # Get the order book of specified market
                        'order_book/{market}',
                        'trades',  # Get recent trades on market, each trade is included only once Trades are sorted in reverse creation order.
                        'trades/{market}',
                        'tickers',  # Get ticker of all markets
                        'tickers/{market}',  # Get ticker of specific market
                        'timestamp',  # Get server current time, in seconds since Unix epoch
                    ],
                },
                'private': {
                    'get': [
                        'account/balances',  # Retrieve user wallet balances.
                        'account/deposit/address',
                        'futures/openOrders',  # Retrieve future open orders
                        'futures/trades',  # This endpoint is used to retrieve your orders execution details
                        'futures/orders',  # Retrieve historical futures orders
                        'spot/openOrders',  # Retrieve spot open orders
                        'spot/orders',  # Retrieve historical spot orders
                        'spot/trades',  # This endpoint is used to retrieve your orders execution details
                    ],
                    'post': [
                        'futures/openOrders',  # This endpoint is used to retrieve future open orders
                        'futures/orders',  # This endpoint is used for placing future orders
                        'spot/openOrders',  # This endpoint is used to retrieve spot open orders
                        'spot/orders',  # This endpoint is used for placing spot orders
                    ],
                    'delete': [
                        'futures/orders/cancel/all',  # Cancle all future Order
                        'futures/orders/cancel/{orderID}',  # Cancel future Order
                        'spot/orders/cancel/all',  # Cancle all spot Orders
                        'spot/orders/cancel/{orderID}',  # Cancel Spot Order
                    ],
                    'put': [
                        'futures/orders',  # This endpoint is used to amend the quantity or price of an open order.
                        'spot/orders',  # This endpoint is used to amend the quantity or price of an open order.
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'maker': 0.2 / 100,
                    'taker': 0.2 / 100,
                },
                'funding': {
                    'tierBased': False,
                    'percentage': True,
                    'withdraw': {},  # There is only 1% fee on withdrawals to your bank account.
                },
            },
            'commonCurrencies': {
                'PLA': 'Plair',
            },
            'exceptions': {
                '2002': InsufficientFunds,
                '2003': OrderNotFound,
            },
            'options': {
                'defaultType': 'spot',  # 'spot', 'future'
            },
        })

    def cancel_all_orders(self, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelAllOrders() requires a symbol argument')
        symbol = self.deal_symbol(symbol, params)
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        self.check_params(params)
        isSpot = self.is_spot(symbol, params)
        response = None
        if isSpot:
            response = self.privateDeleteSpotOrdersCancelAll(self.extend(request, params))
        else:
            response = self.privateDeleteFuturesOrdersCancelAll(self.extend(request, params))
        return {'info': response}

    def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        symbol = self.deal_symbol(symbol, params)
        return self.fetch_orders(symbol, since, limit, self.extend({'orderStatus': 2}, params))

    def cancel_order(self, id, symbol=None, params={}):
        if not id:
            raise ArgumentsRequired(self.id + ' cancelAllOrders() requires a symbol argument')
        self.load_markets()
        request = {
            'orderID': id,
        }
        symbol = self.deal_symbol(symbol, params)
        self.market(symbol)
        self.check_params(params)
        response = None
        # spot or future
        try:
            response = self.privateDeleteSpotOrdersCancelOrderID(request)
        except Exception as error:
            response = self.privateDeleteFuturesOrdersCancelOrderID(request)
        if response and response['code'] != 1:
            raise BadResponse(response['message'])
        # response={
        #     "code":1,
        #     "data":{
        #        "avgPrice":"0",
        #        "base":"BTC",
        #        "clOrdID":"aax",
        #        "commission":"0",
        #        "createTime":"2019-11-12T03:46:41Z",
        #        "cumQty":"0",
        #        "id":"114330021504606208",
        #        "isTriggered":false,
        #        "lastPrice":"0",
        #        "lastQty":"0",
        #        "leavesQty":"0",
        #        "orderID":"wJ4L366KB",
        #        "orderQty":"0.05",
        #        "orderStatus":1,
        #        "orderType":2,
        #        "price":"8000",
        #        "quote":"USDT",
        #        "rejectCode":0,
        #        "rejectReason":null,
        #        "side":1,
        #        "stopPrice":"0",
        #        "symbol":"BTCUSDT",
        #        "transactTime":null,
        #        "updateTime":"2019-11-12T03:46:41Z",
        #        "timeInForce":1,
        #        "userID":"216214"
        #     },
        #     "message":"success",
        #     "ts":1573530402029
        #  }
        order = self.extend(response['data'], {'ts': response['ts']})
        order = self.parse_order(order)
        status = self.safe_string(order, 'status')
        if status == 'closed' or status == 'canceled':
            raise OrderNotFound(self.id + ' ' + self.json(order))
        return order

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        symbol = self.deal_symbol(symbol, params)
        if not (symbol and type and side and amount):
            raise ArgumentsRequired(self.id + ' createOrder  lack of arguments')
        type = type.upper()
        side = side.upper()
        if not self.in_array(type, ['MARKET', 'LIMIT', 'SPOT', 'STOP-LIMIT']):
            raise BadRequest('type must be MARKET, LIMIT, SPOT or STOP-LIMIT')
        self.load_markets()
        request = {
            'orderType': type,
            'symbol': self.market_id(symbol),
            'orderQty': amount,
            'stopPrice': self.safe_string(params, 'stopPrice'),
            'timeInForce': self.safe_string(params, 'timeInForce') if self.safe_string(params, 'timeInForce') else 'GTC',
            'side': side,
        }
        if type == 'LIMIT' or type == 'STOP-LIMIT':
            if not price:
                raise ArgumentsRequired(self.id + ' createOrder LIMIT or STOP-LIMIT need price argument')
            request['price'] = str(price)
        self.check_params(params)
        isSpot = self.is_spot(symbol, params)
        response = None
        if isSpot:
            response = self.privatePostSpotOrders(self.extend(request, params))
        else:
            response = self.privatePostFuturesOrders(self.extend(request, params))
        if response and response['code'] != 1:
            raise BadResponse(response['message'])
        # response={
        #     "code":1,
        #     "data":{
        #        "avgPrice":"0",
        #        "base":"BTC",
        #        "clOrdID":"aax_futures",
        #        "code":"FP",
        #        "commission":"0",
        #        "createTime":null,
        #        "cumQty":"0",
        #        "id":"114375893764395008",
        #        "isTriggered":null,
        #        "lastPrice":"0",
        #        "lastQty":null,
        #        "leavesQty":"100",
        #        "leverage":"1",
        #        "liqType":0,
        #        "marketPrice":"8760.7500000000",
        #        "orderID":"wJTewQc81",
        #        "orderQty":"100",
        #        "orderStatus":0,
        #        "orderType":2,
        #        "price":"8000",
        #        "quote":"USD",
        #        "rejectCode":null,
        #        "rejectReason":null,
        #        "settleType":"INVERSE",
        #        "side":1,
        #        "stopPrice":null,
        #        "symbol":"BTCUSDFP",
        #        "transactTime":null,
        #        "updateTime":null,
        #        "timeInForce":1,
        #        "execInst": "",
        #        "userID":"216214"
        #     },
        #     "message":"success",
        #     "ts":1573541338074
        #  }
        order = self.extend(response['data'], {'ts': response['ts']})
        return self.parse_order(order)

    def edit_order(self, id, symbol, type, side, amount, price=None, params={}):
        self.cancel_order(id, symbol, params)
        return self.create_order(symbol, type, side, amount, price, params)
        # response={
        #     "code":1,
        #     "data":{
        #        "avgPrice":"0",
        #        "base":"BTC",
        #        "clOrdID":"aax",
        #        "commission":"0",
        #        "createTime":"2019-11-12T03:46:41Z",
        #        "cumQty":"0",
        #        "id":"114330021504606208",
        #        "isTriggered":false,
        #        "lastPrice":"0",
        #        "lastQty":"0",
        #        "leavesQty":"0.05",
        #        "orderID":"wJ4L366KB",
        #        "orderQty":"0.05",
        #        "orderStatus":1,
        #        "orderType":2,
        #        "price":"8000",
        #        "quote":"USDT",
        #        "rejectCode":0,
        #        "rejectReason":null,
        #        "side":1,
        #        "stopPrice":"0",
        #        "symbol":"BTCUSDT",
        #        "transactTime":null,
        #        "updateTime":"2019-11-12T03:46:41Z",
        #        "timeInForce":1,
        #        "userID":"216214"
        #     },
        #     "message":"success",
        #     "ts":1573530401494
        # }

    def purse_type(self):
        return {
            'spot': 'SPTP',
            'future': 'FUTP',
            'otc': 'F2CP',
            'saving': 'VLTP',
        }

    def fetch_balance(self, params={}):
        self.load_markets()
        type = self.safe_string(params, 'type') if self.safe_string(params, 'type') else self.options['defaultType']
        self.check_params(params, ['spot', 'future', 'otc', 'saving'])
        purseType = self.purse_type()
        response = self.privateGetAccountBalances({'purseType': purseType[type]})
        # response = {
        #     'code': 1,
        #     'message': 'success',
        #     'ts': 1603187218565,
        #     'data': [
        #         {
        #             'purseType': 'SPTP',
        #             'currency': 'USDT',
        #             'available': '9402.93025232',
        #             'unavailable': '47.92316768',
        #         },
        #         {
        #             'purseType': 'SPTP',
        #             'currency': 'BTC',
        #             'available': '0.14995000',
        #             'unavailable': '0.00000000',
        #         },
        #         {
        #             'purseType': 'RWDP',
        #             'currency': 'BTC',
        #             'available': '0.00030000',
        #             'unavailable': '0.00200000',
        #         },
        #         {
        #             'purseType': 'FUTP',
        #             'currency': 'BTC',
        #             'available': '0.02000000',
        #             'unavailable': '0.20030000',
        #         },
        #     ],
        # }
        # RWDP
        balances = self.safe_value(response, 'data')
        result = {'info': balances}
        for i in range(0, len(balances)):
            balance = balances[i]
            currencyId = self.safe_string(balance, 'currency')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['free'] = self.safe_float(balance, 'available')
            account['used'] = self.safe_float(balance, 'unavailable')
            account['total'] = self.safe_float(balance, 'available') + self.safe_float(balance, 'unavailable')
            result[code] = account
        return self.parse_balance(result)

    def fetch_markets(self, params={}):
        response = self.publicGetInstruments(params)
        # response = {'code': 1,
        #     'message': 'success',
        #     'ts': 1603264508726,
        #     'data': [
        #         {
        #             'tickSize': '0.01',
        #             'lotSize': '1',
        #             'base': 'BTC',
        #             'quote': 'USDT',
        #             'minQuantity': '1.0000000000',
        #             'maxQuantity': '30000',
        #             'minPrice': '0.0100000000',
        #             'maxPrice': '999999.0000000000',
        #             'status': 'enable',
        #             'symbol': 'BTCUSDT',
        #             'code': '',
        #             'takerFee': '0.00040',
        #             'makerFee': '0.00020',
        #             'multiplier': '0.001000000000',
        #             'mmRate': '0.00500',
        #             'imRate': '0.01000',
        #             'type': 'futures',
        #             'settleType': 'Vanilla',
        #             'settleCurrency': 'USDT',
        #         }]}
        markets = self.safe_value(response, 'data')
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            id = self.safe_string(market, 'symbol')
            base = self.safe_string(market, 'base').upper()
            quote = self.safe_string(market, 'quote').upper()
            baseId = base.lower()
            quoteId = quote.lower()
            active = self.safe_string(market, 'status') == 'enable'
            taker = self.safe_float(market, 'takerFee')
            maker = self.safe_float(market, 'makerFee')
            symbol = base + '/' + quote
            if self.safe_string(market, 'code'):
                symbol = symbol + self.safe_string(market, 'code')
            # todo: find out their undocumented precision and limits
            precision = {
                'amount': None,
                'price': None,
                'cost': None,
            }
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'precision': precision,
                'info': market,
                'active': active,
                'taker': taker,
                'maker': maker,
                'percentage': False,
                'tierBased': True,
                'limits': {
                    'amount': {
                        'min': self.safe_string(market, 'minQuantity'),
                        'max': self.safe_string(market, 'maxQuantity'),
                    },
                    'price': {
                        'min': self.safe_string(market, 'minPrice'),
                        'max': self.safe_string(market, 'maxPrice'),
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                },
            })
        return result

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        symbol = self.deal_symbol(symbol, params)
        self.load_markets()
        request = self.deal_since_limit(since, limit)
        self.check_params(params)
        optionType = self.safe_string(params, 'type') if self.safe_string(params, 'type') else self.options['defaultType']
        response = None
        if optionType == 'spot':
            response = self.privateGetSpotTrades(self.extend(request, params))
        else:
            response = self.privateGetFuturesTrades(self.extend(request, params))
        if response and response['code'] != 1:
            raise BadResponse(response['message'])
        # response={
        #     "code":1,
        #     "data":{
        #        "list":[
        #           {
        #              "avgPrice":"8000",
        #              "base":"BTC",
        #              "commission":"0.00000888",
        #              "createTime":"2019-11-12T03:18:35Z",
        #              "cumQty":"0.0148",
        #              "filledPrice":"8000",
        #              "filledQty":"0.0148",
        #              "id":"114322949580906499",
        #              "leavesQty":"0.0052",
        #              "orderID":"wFo9ZPxAJ",
        #              "orderQty":"0.02",
        #              "orderStatus":2,
        #              "orderType":2,
        #              "price":"8000",
        #              "quote":"USDT",
        #              "rejectCode":0,
        #              "rejectReason":null,
        #              "side":1,
        #              "stopPrice":"0",
        #              "symbol":"BTCUSDT",
        #              "taker":false,
        #              "transactTime":"2019-11-12T03:16:16Z",
        #              "updateTime":null,
        #              "userID":"216214"
        #           }
        #        ],
        #        "pageNum":1,
        #        "pageSize":1,
        #        "total":10
        #     },
        #     "message":"success",
        #     "ts":1573532934832
        # }
        trades = response['data']['list']
        return self.parse_my_trades(trades)

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        dateScale = self.deal_time_frame(timeframe)
        symbol = self.deal_symbol(symbol, params)
        self.load_markets()
        [base, quote] = symbol.split('/')
        limit = limit if limit else 500
        request = {
            'limit': limit,
            'base': base,
            'quote': quote,
            'format': 'array',
            'useV1': True,
            'date_scale': dateScale,
        }
        if since is not None:
            request['timestamp'] = int(since / 1000)
        response = self.publicGetGetHistMarketData(self.extend(request, params))
        if response and isinstance(response, list):
            for i in range(0, len(response)):
                if response[i] and isinstance(response[i], list):
                    for index in range(0, len(response[i])):
                        arr = response[i]
                        if index == 0:
                            arr[index] = self.deal_decimal('mul', self.safe_float(arr, index), 1000)
                        else:
                            arr[index] = float(arr[index])
            return self.parse_ohlcvs(response)

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        request = self.deal_since_limit(since, limit)
        symbol = self.deal_symbol(symbol, params)
        if symbol:
            request['symbol'] = self.market_id(symbol)
        self.check_params(params)
        isSpot = self.is_spot(symbol, params)
        response = None
        if isSpot:
            response = self.privateGetSpotOpenOrders(self.extend(request, params))
        else:
            response = self.privateGetFuturesOpenOrders(self.extend(request, params))
        # response={
        #     "code":1,
        #     "data":{
        #        "list":[
        #           {
        #              "avgPrice":"0",
        #              "base":"BTC",
        #              "clOrdID":"aax",
        #              "commission":"0",
        #              "createTime":"2019-11-12T03:41:52Z",
        #              "cumQty":"0",
        #              "id":"114328808516083712",
        #              "isTriggered":false,
        #              "lastPrice":"0",
        #              "lastQty":"0",
        #              "leavesQty":"0",
        #              "orderID":"wJ3qitASB",
        #              "orderQty":"0.02",
        #              "orderStatus":1,
        #              "orderType":2,
        #              "price":"8000",
        #              "quote":"USDT",
        #              "rejectCode":0,
        #              "rejectReason":null,
        #              "side":1,
        #              "stopPrice":"0",
        #              "symbol":"BTCUSDT",
        #              "transactTime":null,
        #              "updateTime":"2019-11-12T03:41:52Z",
        #              "timeInForce":1,
        #              "userID":"216214"
        #           }
        #        ],
        #        "pageNum":1,
        #        "pageSize":2,
        #        "total":2
        #     },
        #     "message":"success",
        #     "ts":1573553718212
        #  }
        orders = response['data']['list']
        result = []
        for i in range(0, len(orders)):
            order = self.extend(orders[i])
            result.append(self.parse_order(order))
        return result

    def fetch_order(self, id=None, symbol=None, params={}):
        self.load_markets()
        request = {}
        if not id:
            raise ArgumentsRequired(self.id + ' editOrder need orderId argument')
        request['orderID'] = id
        symbol = self.deal_symbol(symbol, params)
        if symbol:
            request['symbol'] = self.market_id(symbol)
        self.check_params(params)
        isSpot = self.is_spot(symbol, params)
        response = None
        if isSpot:
            response = self.privateGetSpotOrders(self.extend(request, params))
        else:
            response = self.privateGetFuturesOrders(self.extend(request, params))
        # response={
        #     "code":1,
        #     "data":{
        #        "total":19,
        #        "pageSize":10,
        #        "list":[
        #           {
        #              "orderType":2,
        #              "symbol":"BTCUSDT",
        #              "avgPrice":"0",
        #              "orderStatus":0,
        #              "userID":"7225",
        #              "quote":"USDT",
        #              "rejectReason":null,
        #              "rejectCode":null,
        #              "price":"0",
        #              "orderQty":"0.002",
        #              "commission":"0",
        #              "id":"110419975166304256",
        #              "isTriggered":null,
        #              "side":1,
        #              "orderID":"vBGlDcLwk",
        #              "cumQty":"0",
        #              "leavesQty":"0",
        #              "updateTime":null,
        #              "clOrdID":"0001",
        #              "lastQty":"0",
        #              "stopPrice":"0",
        #              "createTime":"2019-11-01T08:49:33Z",
        #              "transactTime":null,
        #              "timeInForce":1,
        #              "base":"BTC",
        #              "lastPrice":"0"
        #           }
        #        ],
        #        "pageNum":1
        #     },
        #     "message":"success",
        #     "ts":1572598173682
        #  }
        orders = response['data']['list']
        result = []
        for i in range(0, len(orders)):
            order = self.extend(orders[i])
            result.append(self.parse_order(order))
        return result

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        symbol = self.deal_symbol(symbol, params)
        self.load_markets()
        request = self.deal_since_limit(since, limit)
        self.check_params(params)
        isSpot = self.is_spot(symbol, params)
        if symbol:
            request['symbol'] = self.market_id(symbol)
        response = None
        if isSpot:
            response = self.privateGetSpotOrders(self.extend(request, params))
        else:
            response = self.privateGetFuturesOrders(self.extend(request, params))
        # response={
        #     "code":1,
        #     "data":{
        #        "total":19,
        #        "pageSize":10,
        #        "list":[
        #           {
        #              "orderType":2,
        #              "symbol":"BTCUSDT",
        #              "avgPrice":"0",
        #              "orderStatus":0,
        #              "userID":"7225",
        #              "quote":"USDT",
        #              "rejectReason":null,
        #              "rejectCode":null,
        #              "price":"0",
        #              "orderQty":"0.002",
        #              "commission":"0",
        #              "id":"110419975166304256",
        #              "isTriggered":null,
        #              "side":1,
        #              "orderID":"vBGlDcLwk",
        #              "cumQty":"0",
        #              "leavesQty":"0",
        #              "updateTime":null,
        #              "clOrdID":"0001",
        #              "lastQty":"0",
        #              "stopPrice":"0",
        #              "createTime":"2019-11-01T08:49:33Z",
        #              "transactTime":null,
        #              "timeInForce":1,
        #              "base":"BTC",
        #              "lastPrice":"0"
        #           }
        #        ],
        #        "pageNum":1
        #     },
        #     "message":"success",
        #     "ts":1572598173682
        #  }
        orders = response['data']['list']
        result = []
        for i in range(0, len(orders)):
            order = self.extend(orders[i])
            result.append(self.parse_order(order))
        return result

    def fetch_order_book(self, symbol, limit=None, params={}):
        if limit and not self.in_array(limit, [20, '20', 50, '50']):
            raise BadRequest('limit must be 20 or 50 ')
        symbol = self.deal_symbol(symbol, params)
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        request['level'] = limit if limit else 20  # Support 20, 50
        orderbook = self.publicGetMarketOrderbook(self.extend(request, params))
        timestamp = self.safe_timestamp(orderbook, 't') / 1000  # need unix type
        return self.parse_order_book(orderbook, timestamp)

    def fetch_ticker(self, symbol, params={}):
        symbol = self.deal_symbol(symbol, params)
        self.load_markets()
        market = self.market(symbol)
        value = market['id']
        response = self.publicGetMarketTickers()
        ticket = self.extend(self.filter_by(response['tickers'], 's', value)[0], {'at': response['t']})
        return self.parse_ticker(ticket, market)

    def fetch_tickers(self, symbols=[], params={}):
        self.load_markets()
        response = self.publicGetMarketTickers()
        # response = {
        #     'e': 'tickers',
        #     't': 1592568022678,
        #     'tickers':
        #     [
        #         {
        #             'a': '0.00000000',
        #             'c': '52.50000000',
        #             'd': '-0.94339623',
        #             'h': '53.00000000',
        #             'l': '50.80000000',
        #             'o': '53.00000000',
        #             's': 'ZECUSDT',
        #             'v': '42525.11699994',
        #         },
        #         {
        #             'a': '0.00000000',
        #             'c': '0.00000222',
        #             'd': '-5.53191489',
        #             'h': '0.00000236',
        #             'l': '0.00000216',
        #             'o': '0.00000235',
        #             's': 'ZILBTC',
        #             'v': '5.84912230',
        #         },
        #     ],
        # }
        tickers = response['tickers']
        result = []
        if tickers and isinstance(tickers, list):
            for index in range(0, len(tickers)):
                ticker = tickers[index]
                ticker = self.extend(ticker, {'at': response['t']})
                result.append(self.parse_ticker(ticker))
        return self.filter_by_array(result, 'symbol', symbols)

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        symbol = self.deal_symbol(symbol, params)
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'limit': 2,  # max 2000
        }
        response = self.publicGetMarketTrades(request)
        return self.parse_trades(response['trades'], market, since, limit)

    def parse_ticker(self, ticker, market=None):
        timestamp = ticker['at']
        obj = self.safe_value(self.marketsById, self.safe_string(ticker, 's'))
        symbol = self.safe_string(obj, 'symbol') if obj else None
        if market:
            symbol = market['symbol']
        if symbol and symbol[-2:] == 'FP':
            symbol = symbol[0:-2]
        last = self.safe_float(ticker, 'c')
        open = self.safe_float(ticker, 'o')
        change = self.deal_decimal('sub', last, open)
        percentage = self.deal_decimal('mul', self.deal_decimal('div', change, open), 100) if (open and change) else None
        average = self.deal_decimal('div', self.deal_decimal('add', last, open), 2)
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, 'h'),
            'low': self.safe_float(ticker, 'l'),
            'bid': None,
            'bidVolume': None,
            'ask': None,
            'askVolume': None,
            'vwap': None,
            'open': open,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': change,
            'percentage': percentage,
            'average': average,
            'baseVolume': None,
            'quoteVolume': None,
            'info': ticker,
        }

    def parse_trade(self, trade, market=None):
        timestamp = self.safe_float(trade, 't')
        id = self.safe_string(trade, 'tid')
        symbol = None
        if market is not None:
            symbol = market['symbol']
        if symbol and symbol[-2:] == 'FP':
            symbol = symbol[0:-2]
        price = self.safe_float(trade, 'p')
        amount = self.safe_float(trade, 'q')
        side = price > 'buy' if 0 else 'sell'
        cost = self.deal_decimal('mul', price, amount)
        currency = symbol.split('/')[1] if symbol else 'currency'
        return {
            'info': trade,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'type': None,
            'side': side,
            'order': None,
            'takerOrMaker': None,
            'price': abs(price),
            'amount': amount,
            'cost': abs(cost),
            'fee': {
                'cost': None,
                'currency': currency,
                'rate': None,
            },
        }

    def parse_my_trade(self, trade):
        id = self.safe_string(trade, 'id')
        orderId = self.safe_string(trade, 'orderID')
        createTime = self.safe_string(trade, 'createTime')
        timestamp = createTime if createTime else None
        symbol = self.safe_string(trade, 'symbol')
        symbol = self.marketsById[symbol]['symbol'] if symbol else symbol
        if symbol and symbol[-2:] == 'FP':
            symbol = symbol[0:-2]
        price = self.safe_float(trade, 'price')
        type = self.parse_order_type(self.safe_string(trade, 'orderType'))
        side = self.safe_string(trade, 'side') == 'Buy' if 1 else 'Sell'
        amount = self.safe_float(trade, 'filledQty')
        return {
            'info': trade,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'type': type,
            'side': side,
            'order': orderId,
            'takerOrMaker': 'taker',
            'price': price,
            'amount': amount,
            'cost': self.deal_decimal('mul', price, amount),
            'fee': {
                'currency': None,
                'cost': None,
                'rate': None,
            },
        }

    def parse_my_trades(self, trades):
        result = []
        for i in range(0, len(trades)):
            trade = trades[i]
            trade = self.parse_my_trade(trade)
            result.append(trade)
        return result

    def parse_trades(self, trades, market=None, since=None, limit=None, params={}):
        lists = []
        for i in range(0, len(trades)):
            trade = trades[i]
            lists.append(self.parse_trade(trade, market))
        trades = lists
        result = self.sort_by(trades, 'timestamp')
        symbol = None
        if market and self.safe_string(market, 'symbol'):
            symbol = self.safe_string(market, 'symbol')
            if symbol[-2:] == 'FP':
                symbol = symbol[0:-2]
        return self.filter_by_symbol_since_limit(result, symbol, since, limit)

    def parse_order_status(self, status):
        statuses = {
            '0': 'open',  # open
            '1': 'open',  # open
            '2': 'closed',  # closed
            '3': 'closed',  # closed
            '4': 'cancled',  # cancled
            '5': 'cancled',  # cancled
            '6': 'rejected',  # Rejected
            '10': 'cancled',  # cancled
            '11': 'rejected',  # Rejected
        }
        return self.safe_string(statuses, status, status)

    def parse_order_type(self, status):
        statuses = {
            '1': 'market',
            '2': 'limit',
            '3': 'Stop Order',
            '4': 'Stop-Limit Order',
            '7': 'Stop Loss',
            '8': 'Take Profit',
        }
        return self.safe_string(statuses, status, status)

    def parse_order(self, order):
        createTime = self.safe_string(order, 'createTime')
        timestamp = createTime if createTime else self.safe_float(order, 'ts')
        status = self.parse_order_status(self.safe_string(order, 'orderStatus'))
        type = self.parse_order_type(self.safe_string(order, 'orderType'))
        side = self.safe_string(order, 'side') == 'buy' if 1 else 'sell'
        id = self.safe_string(order, 'orderID')
        clientOrderId = self.safe_string(order, 'clOrdID')
        symbol = self.safe_string(order, 'symbol')
        symbol = self.marketsById[symbol]['symbol'] if symbol else symbol
        if symbol and symbol[-2:] == 'FP':
            symbol = symbol[0:-2]
        price = self.safe_float(order, 'price')
        average = self.safe_float(order, 'avgPrice')
        amount = self.safe_float(order, 'orderQty')
        filled = self.safe_float(order, 'cumQty')
        remaining = self.safe_string(order, 'leavesQty')
        transactTime = self.safe_string(order, 'transactTime')
        lastTradeTimestamp = transactTime if transactTime else None
        currency = None
        return {
            'id': id,
            'clientOrderId': clientOrderId,
            'timestamp': timestamp,
            'datetime': self.parse_date(timestamp),
            'lastTradeTimestamp': lastTradeTimestamp,
            'status': status,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'average': average,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'rejectReason': self.safe_string(order, 'rejectReason'),
            'cost': self.deal_decimal('mul', filled, price),
            'trades': [],
            'info': order,
            'fee': {
                'currency': currency,
                'cost': None,
                'rate': None,
            },
        }

    def nonce(self):
        return self.milliseconds()

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        version = self.version
        if self.safe_string(params, 'useV1'):
            version = self.v1
        request = '/' + version + '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        url = self.urls['api'] + request
        if api == 'public':
            if query:
                url += '?' + self.urlencode(query)
        else:
            self.check_required_credentials()
            nonce = str(self.nonce())
            privateHeader = {
                'X-ACCESS-KEY': self.apiKey,
                'X-ACCESS-NONCE': nonce,
            }
            suffix = self.urlencode(query)
            if method == 'GET':
                url = (url + '?' + suffix) if suffix else url
                request = (request + '?' + suffix) if suffix else request
                payload = {
                    'nonce': nonce,
                    'verb': method,
                    'path': request,
                    'data': '',
                }
                sign = self.get_sign_from_secret(payload)
                privateHeader['X-ACCESS-SIGN'] = sign
                headers = self.extend({'accept': 'application/json;charset=UTF-8'}, privateHeader)
            else:
                payload = {
                    'nonce': nonce,
                    'verb': method,
                    'path': request,
                    'data': self.json(query, {'convertArraysToObjects': True}),
                }
                sign = self.get_sign_from_secret(payload)
                privateHeader['X-ACCESS-SIGN'] = sign
                body = self.json(query, {'convertArraysToObjects': True})
                headers = self.extend({'Content-Type': 'application/json'}, privateHeader)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return
        if code == 400:
            error = self.safe_value(response, 'error')
            errorCode = self.safe_string(error, 'code')
            feedback = self.id + ' ' + self.json(response)
            self.throw_exactly_matched_exception(self.exceptions, errorCode, feedback)
            # fallback to default error handler

    def get_sign_from_secret(self, params):
        nonce = self.safe_string(params, 'nonce')
        verb = self.safe_string(params, 'verb')
        path = self.safe_string(params, 'path')
        data = self.safe_string(params, 'data')
        message = nonce + ':' + verb + path + data
        return self.hmac(self.encode(message), self.encode(self.secret))

    def check_params(self, params, arr=[]):
        if not self.in_array(self.options['defaultType'], ['spot', 'future']):
            raise BadRequest('defaultType must be spot or future')
        if self.is_empty(arr):
            arr = ['spot', 'future']
        type = self.options['defaultType']
        if params and self.safe_string(params, 'type'):
            type = self.safe_string(params, 'type')
            if not self.in_array(type, arr):
                raise BadRequest('params.type must be' + ','.join(arr))

    def deal_since_limit(self, since, limit):
        result = {}
        if since:
            result['startDate'] = self.ymd(since)
        if limit:
            result['pageSize'] = limit
        return result

    def deal_time_frame(self, timeframe):
        dateScale = self.timeframes[timeframe]
        if not dateScale:
            keys = list(self.timeframes.keys())
            error = ','.join(keys)
            raise BadRequest('timeframes must be ' + error)
        return dateScale

    def deal_symbol(self, symbol, params):
        self.check_params(params)
        type = self.options['defaultType']
        if self.safe_string(params, 'type'):
            type = self.safe_string(params, 'type')
        isSpot = type == 'spot'
        if symbol:
            if not isSpot and symbol[-2:] != 'FP':
                symbol = symbol + 'FP'
        return symbol

    def deal_decimal(self, op, num1, num2, digits=8):
        result = 0
        num1 = float(num1)
        num2 = float(num2)
        if op == 'add':
            result = self.decimal_to_precision(self.sum(num1, num2), ROUND, digits, self.precisionMode)
        if op == 'sub':
            result = self.decimal_to_precision(num1 - num2, ROUND, digits, self.precisionMode)
        if op == 'mul':
            result = self.decimal_to_precision(num1 * num2, ROUND, digits, self.precisionMode)
        if op == 'div':
            result = self.decimal_to_precision(num1 / num2, ROUND, digits, self.precisionMode)
        return float(result)

    def is_spot(self, symbol, params):
        optionType = self.options['defaultType']
        if self.safe_string(params, 'type'):
            optionType = self.safe_string(params, 'type')
        if symbol:
            return optionType == 'spot' and symbol[-2:] != 'FP'
        return optionType == 'spot'
