# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
from ccxt.base.errors import InsufficientFunds, ExchangeError, BadRequest, ArgumentsRequired
from ccxt.base.errors import OrderNotFound


class aax(Exchange):
    def describe(self):
        return self.deep_extend(
            super(aax, self).describe(),
            {
                'id': 'aax',
                'name': 'AAX',
                'countries': ['MT'],
                'rateLimit': 1000,
                'version': 'v2',
                "version_1": "marketdata/v1",
                'has': {
                    'cancelAllOrders': True,
                    'createLimitOrder': False,
                    'createMarketOrder': False,
                    'cancelOrder': True,
                    'createOrder': True,
                    'editOrder': True,
                    'fetchAllOrders': True,
                    'fetchBalance': True,
                    'fetchClosedOrders': True,
                    'fetchDepositAddress': False,
                    'fetchMarkets': True,
                    'fetchMyTrades': True,
                    'fetchOHLCV': True,
                    'fetchOpenOrders': True,
                    'fetchOrder': True,
                    'fetchOrders': True,
                    'fetchOrderBook': True,
                    'fetchOrderTrades': True,
                    'fetchTicker': True,
                    'fetchTickers': True,
                    'fetchTrades': True,
                    'fetchTradingLimits': False,
                },
                'timeframes': {
                    '1m': '1',
                    '5m': '5',
                    '15m': '15',
                    '30m': '30',
                    '1h': '60',
                    '2h': '120',
                    '4h': '240',
                    '12h': '720',
                    '1d': '1440',
                    '3d': '4320',
                    '1w': '10080',
                },
                'urls': {
                    'logo': 'https://www.aaxpro.com/static/images/logo/AAX_Logo.png',
                    'api': 'https://api.aaxpro.com',
                    'www': 'https://www.aaxpro.com',  # string website URL
                    'doc': 'https://www.aax.com/apidoc/index.html',
                },
                'api': {
                    'public': {
                        'get': [
                            'instruments',  # This endpoint is used to retrieve all instruments information.
                            'getHistMarketData',  # Get OHLC(k line) of specific market
                            'market/orderbook',
                            # This endpoint allows you to retrieve the current order book for a specific symbol.
                            'market/tickers',
                            # This endpoint allows you to retrieve the trading summary for all symbol in the last 24 hours
                            'market/trades',  # Get the Most Recent Trades
                            'order_book',  # Get the order book of specified market
                            'order_book/{market}',
                            'tickers',  # Get ticker of all markets
                            'tickers/{market}',  # Get ticker of specific market
                            'trades',
                            # Get recent trades on market, each trade is included only once Trades are sorted in reverse creation order.
                            'trades/{market}',
                            'timestamp',  # Get server current time, in seconds since Unix epoch
                        ],
                    },
                    'private': {
                        'get': [
                            'account/balances',  # Retrieve user wallet balances.
                            'account/deposit/address',
                            'spot/orders',  # Retrieve historical spot orders
                            'spot/openOrders',  # Retrieve spot open orders
                            'spot/trades',  # This endpoint is used to retrieve your orders execution details
                            'futures/orders',  # Retrieve historical futures orders
                            'futures/openOrders',  # Retrieve futures open orders
                            'futures/trades',  # This endpoint is used to retrieve your orders execution details
                        ],
                        'post': [
                            'spot/orders',  # This endpoint is used for placing spot orders
                            'spot/openOrders',  # This endpoint is used to retrieve spot open orders
                            'futures/orders',  # This endpoint is used for placing futures orders
                            'futures/openOrders',  # This endpoint is used to retrieve futures open orders
                        ],
                        'delete': [
                            'futures/orders/cancel/all',  # Cancel all futures Order
                            'futures/orders/cancel/{orderID}',  # Cancel futures Order
                            'spot/orders/cancel/{orderID}',  # Cancel Spot Order
                            'spot/orders/cancel/all',  # Cancel futures Order
                        ],
                        'put': [
                            'spot/orders',  # This endpoint is used to amend the quantity or price of an open order.
                            'futures/orders'  # This endpoint is used to amend the quantity or price of an open order.
                        ]
                    }
                },
                'fees': {
                    'trading': {
                        'tierBased': False,
                        'percentage': True,
                        'maker': 0.2 / 100,
                        'taker': 0.2 / 100,
                    },
                    'funding': {
                        'tierBased': False,
                        'percentage': True,
                        'withdraw':
                        {},  # There is only 1% fee on withdrawals to your bank account.
                    },
                },
                'commonCurrencies': {
                    'PLA': 'Plair',
                },
                'exceptions': {
                    '2002': InsufficientFunds,
                    '2003': OrderNotFound,
                },
                'options': {
                    'defaultType': 'spot',  # 'spot', 'future'
                },
            })

    def cancel_all_orders(self, symbol=None, params={}):
        if not symbol:
            raise Exception(self.id +
                            " cancelAllOrders() requires a symbol argument")
        symbol = self.deal_symbol(symbol, params)
        self.load_markets()
        market = self.market(symbol)
        request = {"symbol": market["id"]}
        self.check_params(params)
        option_type = params.get("type", None) or self.options["defaultType"]

        response = self.privateDeleteSpotOrdersCancelAll(self.extend(request,
                                                                     params)) if option_type == "spot" \
            else self.privateDeleteFuturesOrdersCancelAll(self.extend(request,
                                                                      params))

        return response

    def cancel_order(self, id, symbol=None, params={}):
        # XXX error with respond
        if not id:
            raise ArgumentsRequired(
                self.id + "cancelAllOrders() requires a symbol argument")
        self.load_markets()
        request = {
            'orderID': id,
        }

        symbol = self.deal_symbol(symbol, params)
        if symbol:
            self.market(symbol)
        self.check_params(params)
        option_type = params.get("type", None) or self.options["defaultType"]

        response = self.privateDeleteSpotOrdersCancelOrderID(self.extend(request,
                                                                         params)) if option_type == "spot" \
            else self.privateDeleteFuturesOrdersCancelOrderID(self.extend(request, params))

        if not response and response["code"] != 1:
            raise Exception("request error" + response["message"])
        order = self.parse_order(response)
        status = order['status']
        if status == 'closed' or status == 'canceled':
            raise Exception(OrderNotFound(self.id + ' ' + self.json(order)))
        return order

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        if not all([symbol, type, side, amount]):
            raise Exception(self.id + "createOrder lack of arguments")
        type = type.upper()
        side = side.upper()

        symbol = self.deal_symbol(symbol, params)

        if type not in ['MARKET', 'LIMIT', 'STOP', 'STOP-LIMIT']:
            raise BadRequest('type must be MARKET, LIMIT, STOP or STOP-LIMIT')
        request = {
            'symbol': self.market_id(symbol),
            'side': side,
            'timeInForce': params.get("timeInForce", "GTC"),
            'stopPric': params.get("stopPrice", None),
            'orderQty': str(amount),
            'orderType': type,
        }
        # TODO and STOP, MARKET
        if type == 'LIMIT' or type == "STOP-LIMIT":
            if not price:
                raise ArgumentsRequired(
                    self.id +
                    "createOrder LIMIT or STOP-LIMIT need price argument")
            request['price'] = str(price)
        self.check_params(params)
        # response = self.privatePostOrders(self.extend(request, params))

        option_type = params.get("type") or self.options["defaultType"]

        response = self.privatePostSpotOrders(self.extend(request, params)) if option_type == "spot" else \
            self.privatePostFuturesOrders(self.extend(request, params))
        if not response or response["code"] != 1:
            raise ExchangeError(self.id + response["message"])

        # marketId = self.safe_value(response, 'market')
        # market = self.safe_value(self.markets_by_id, marketId)
        order = self.extend(response["data"], {"ts": response["ts"]})
        return self.parse_order(order)

    #
    # def create_limit_order(self, symbol, *args):
    #     return self.create_order(symbol, "LIMIT", *args)

    # def create_market_order(self, symbol, *args):
    #     return self.create_order(symbol, *args)

    def edit_order(self,
                   id,
                   symbol=None,
                   amount=None,
                   price=None,
                   stopPrice=None,
                   params={}):

        if not all([id]):
            raise Exception(self.id + "editOrder need orderId argument")
        self.load_markets()
        request = {
            'orderID': id,
        }
        request.update(params)
        symbol = self.deal_symbol(symbol, params)
        if symbol:
            request["symbol"] = self.market_id(symbol)
        if amount:
            request['orderQty'] = amount
        if price:
            request['price'] = price
        if stopPrice:
            request['stopPrice'] = stopPrice

        self.check_params(params)
        option_type = params.get("type") or self.options["defaultType"]
        response = self.privatePutSpotOrders(self.extend(request,
                                                         params)) if option_type == "spot" \
            else self.privatePutFuturesOrders(
            self.extend(request, params))
        if not response or response["code"] != 1:
            raise BadRequest("Bad response: " + response["message"])
        order = self.extend(response["data"], {"ts": response["ts"]})
        return self.parse_order(order)

    def fetch_all_order(self, id=None, side=None, symbol=None, params={}):
        return self.fetch_order(id, symbol, params)

    def fetch_balance(self, params={}):
        # TODO with balance new logic
        self.load_markets()
        type = self.safe_string(params, "type", "spot")
        self.check_params(params, ['spot', 'future', 'otc', 'saving'])
        purse_type = self.pures_type()
        params["purseType"] = purse_type[type]
        del params["type"]
        response = self.privateGetAccountBalances(params)

        balances = self.safe_value(response, 'data')

        result = {'info': balances}
        for i in range(0, len(balances)):
            balance = balances[i]
            currencyId = self.safe_string(balance, 'currency')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['free'] = self.safe_float(balance, 'available')
            account['used'] = self.safe_float(balance, 'unavailable')
            account['total'] = self.safe_float(balance,
                                               "available") + self.safe_float(
                                                   balance, 'unavailable')
            result[code] = account
        return self.parse_balance(result)

    def fetch_closed_orders(self, id=None, side=None, symbol=None, params={}):
        symbol = self.deal_symbol(symbol, params)
        return self.fetch_all_order(id,
                                    side=side,
                                    symbol=symbol,
                                    params=params)

    # def fetch_deposit_address(self, code=None, since=None, limit=None, params={}):
    #     request = {"currency": params.get("currency", None),
    #                "network": params.get("network", None)}
    #     response = self.privateGetAccountDepositAddress(self.extend(request, params))
    #     data = response.data
    #     return {
    #         "currency": self.safe_string(data, "currency"),
    #         "address": self.safe_string(data, "address"),
    #         "tag": self.safe_string(data, "tag"),
    #         "info": data
    #     }

    def fetch_markets(self, params={}):
        res = self.publicGetInstruments(params)

        precision = {
            'amount': None,
            'price': None,
        }
        result = []
        if res and res["code"] == 1:
            for i in res["data"]:
                new_data = dict()
                new_data["info"] = i
                new_data["id"] = i["symbol"]
                new_data["taker"] = i["takerFee"]
                new_data["maker"] = i["makerFee"]
                new_data["tierBased"] = True
                new_data["base"] = i["base"].upper()
                new_data["quote"] = i["quote"].upper()
                new_data["baseId"] = i["base"].lower()
                new_data["quoteId"] = i["quote"].lower()
                new_data["active"] = True if i["status"] == "enable" else False
                new_data["symbol"] = new_data["base"] + "/" + new_data[
                    "quote"] + (i.get("code") or "")
                new_data["precision"] = precision
                # new add in 10.22
                new_data["percentage"] = False
                new_data["limits"] = {
                    "amount": {
                        "max": i["maxQuantity"],
                        "min": i["minQuantity"]
                    },
                    "price": {
                        "min": i["minPrice"],
                        "max": i["maxPrice"]
                    },
                    "cost": {
                        # TODO futuer 处理方式
                        # XXX
                        'min': None,
                        'max': None,
                    }
                }
                result.append(new_data)

        return result

    def fetch_order_book(self, symbol, limit=None, params={}):
        symbol = self.deal_symbol(symbol, params)
        self.load_markets()
        market = self.market(symbol)
        request = {'symbol': market['id'], "level": limit or 20}
        # XXX add error mmessage level must be 20,  50
        if limit is not None:
            request['limit'] = int(limit)  # default = 300
            limit = int(limit)
        if limit != 20 and limit != 50:
            raise BadRequest("limit must be 20 or 50.")

        orderbook = self.publicGetMarketOrderbook(self.extend(request, params))
        # TODO add get orderbook "t"
        timestamp = self.safe_timestamp(orderbook, 't') // 1000
        return self.parse_order_book(orderbook, timestamp)

    def fetch_ticker(self, symbols=None, params={}):
        # TODO  XXX 根据params 确定是futuers 还是sopt
        self.load_markets()
        symbol = self.deal_symbol(symbols, params)
        market = self.market(symbol)

        value = market["id"]
        response = self.publicGetMarketTickers()

        ticket = self.extend(
            self.filterBy(response.get("tickers"), "s", value)[0],
            {"at": response["t"]})
        if isinstance(ticket, dict):
            ticket["reset_symbol"] = ticket["s"]
        # if isinstance(ticket, dict):
        #     ticket["t"] = response['t']
        # else:
        #     import ast
        #     ticket = ast.literal_eval(ticket)
        #     ticket["t"] = response['t']

        return self.parse_ticker(ticket, market)

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        symbols = self.deal_symbol(symbols, params)

        response = self.publicGetMarketTickers()

        if not isinstance(symbols, list):
            raise BadRequest("Bad request params with symbols.")

        sybo = self.market() if not symbols else {
            self.market(i)["id"]: self.market(i)
            for i in symbols
        }
        ticket = [i for i in response.get("tickers") if i["s"] in sybo.keys()]
        # sybo = {self.markets(i)["s"]: self.market(i) for i in symbols}
        # ticket = response.get("tickers")

        result = []
        for i in ticket:
            if sybo.get(i["s"]):
                i.update({"at": response["t"]})
                # TODO using original method the self.extand have some errror.
                ticket = i
                result.append(self.parse_ticker(ticket))

        return result

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        request = self.deal_since_limit(since, limit)
        symbol = self.deal_symbol(symbol, params)
        self.check_params(params)
        option_type = params.get("type") or self.options["defaultType"]
        response = self.privateGetSpotTrades(self.extend(request, params)) if option_type == "spot" \
            else self.privateGetFuturesTrades(self.extend(request, params))
        if not response and response["code"] != 1:
            raise Exception("Bad response" + response["message"])
        trades = response["data"]["list"]
        return self.parse_my_trades(trades)

    def fetch_time(self, params={}):
        response = self.publicGetTimestamp(params)
        #
        #     1594911427
        #
        return response * 1000

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        # FIXME the error with id
        self.load_markets()
        symbol = self.deal_symbol(symbol, params)

        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            "limit": 2  # max 2000
        }
        response = self.publicGetMarketTrades(self.extend(request, params))
        return self.parse_trades(response["trades"], market, since, limit)

    def fetch_trading_limits(self, param={}):
        return self.fetch_markets(param)

    def fetch_ohlcv(self,
                    symbol,
                    timeframe='1m',
                    since=None,
                    limit=None,
                    params={}):
        # FIXME update with new ai
        symbol = self.deal_symbol(symbol, params)
        self.load_markets()
        market = self.market(symbol)
        timeframe = self.timeframes[timeframe]
        base = symbol.split("/")[0]
        quote = symbol.split("/")[1]

        request = {
            'base': base,
            'quote': quote,
            "format": "array",
            "limit": 5 if not limit else limit,
            'date_scale': timeframe,
            "use_v1": True
        }
        if since is not None:
            request['timestamp'] = int(since / 1000)
        response = self.publicGetGetHistMarketData(self.extend(
            request, params))

        return self.parse_ohlcvs(response, market, timeframe, since)

    def fetch_order(self, id, symbol=None, params={}):
        symbol = self.deal_symbol(symbol, params)
        self.load_markets()
        # print(self.load_markets())

        request = dict()
        if id:
            request["orderID"] = id

        if symbol:
            request["symbol"] = self.market_id(symbol)
        self.check_params(params)
        option_type = params.get("type") or self.options["defaultType"]
        response = self.privateGetSpotOrders(self.extend(request,
                                                         params)) if  \
        option_type == "spot" and symbol[:-2] != "FP" \
            else self.privateGetFuturesOrders(self.extend(
                request, params))
        orders = response["data"]["list"]
        # fetch symbol by ccxt

        result = [self.parse_order(self.extend(i)) for i in orders]

        return result

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        symbol = self.deal_symbol(symbol, params)
        # TODO make the method with fetch_order.
        self.load_markets()
        request = self.deal_since_limit(since=since, limit=limit)
        self.check_params(params)
        option_type = params.get("type") or self.options["defaultType"]
        if symbol:
            request["symbol"] = self.market_id(symbol)
        response = self.privateGetSpotOrders(
            self.extend(request, params)
        ) if option_type == "spot" and symbol[:-2] != "FP"  \
    else self.privateGetFuturesOrders(
            self.extend(request, params))

        orders = response["data"]["list"]

        result = [self.parse_order(self.extend(i)) for i in orders]
        return result

    def fetch_order_trades(self,
                           id,
                           symbol=None,
                           since=None,
                           limit=None,
                           params={}):
        symbol = self.deal_symbol(symbol, params)
        return self.fetch_my_trades(symbol,
                                    since=since,
                                    limit=limit,
                                    params=self.extend({"orderID": id},
                                                       params))

    def fetch_open_orders(self,
                          symbol=None,
                          since=None,
                          limit=None,
                          params={}):
        self.load_markets()

        request = self.deal_since_limit(since, limit)
        symbol = self.deal_symbol(symbol, params)
        if symbol:
            request["symbol"] = self.market_id(symbol)
        self.check_params(params)
        option_type = params.get("type", None) or self.options["defaultType"]

        response = self.privateGetSpotOpenOrders(self.extend(request, params)) if option_type == "spot" else \
            self.privateGetFuturesOpenOrders(self.extend(request, params))

        orders = response["data"]["list"]

        result = [self.parse_order(self.extend(i)) for i in orders]
        return result

    def parse_order_status(self, status):
        statuses = {
            '0': 'Pending-New',
            '1': 'New',
            '2': 'Partially-Filled',
            '3': 'Filled',
            '4': 'Cancel-Reject',
            '5': 'Canceled',
            '6': 'Rejected',
            '10': 'Expired',
            '11': 'Business-Reject',
        }

        return self.safe_string(statuses, status, status)

    def parse_order_type(self, stauts):
        statuses = {
            '1': 'Market Order',
            '2': 'Limit Order',
            '3': 'Stop Order',
            '4': 'Stop-Limit Order',
            '7': 'Stop Loss',
            '8': 'Take Profit',
        }
        return self.safe_string(statuses, stauts, stauts)

    def parse_trade(self, trade, market=None):
        timestamp = self.safe_string(trade, 't')
        id = self.safe_string(trade, 'tid')
        symbol = None
        if market is not None:
            symbol = market['symbol']

        if symbol and symbol.endswith("FP"):
            symbol = symbol[:-2]
        price = self.safe_float(trade, "p")
        amount = self.safe_float(trade, "q")
        side = "buy" if price > 0 else "sell"
        # XXX delete cost and currency
        # cost = price * amount
        # currency = "currency" if not symbol else symbol.split("/")[1]
        return {
            'info': trade,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(int(timestamp)),
            'symbol': symbol,
            'type': None,
            'side': side,
            'order': None,
            'takerOrMaker': None,
            'price': abs(price),
            'amount': amount,
            # 'cost': abs(cost),
            # 'fee': {
            #     "cost": None,
            #     "currency": currency,
            #     "rate": None
            # }
        }

    def parse_trades(self,
                     trades,
                     market=None,
                     since=None,
                     limit=None,
                     params={}):

        trades = [self.parse_trade(i, market) for i in trades]

        result = self.sort_by(trades, "timestamp")
        symbol = None if market == None else market.get("symbol") if not \
        market["symbol"].endswith("FP") else market["symbol"][:-2]
        

        return self.filter_by_symbol_since_limit(result, symbol, since, limit)

    def parse_my_trade(self, trade):
        id = self.safe_string(trade, "id")
        order_id = self.safe_string(trade, "orderID")

        timestamp = None if not trade.get("createTime") else self.get_time(
            self.safe_string(trade, "createTime"))
        symbol = self.safe_string(trade, "symbol")
        price = self.safe_float(trade, "price")
        order_type = self.parse_order_type(self.safe_string(
            trade, "orderType"))
        side = "Buy" if self.safe_string(trade, "side") == 1 else "Sell"
        amount = self.safe_float(trade, "filledQty")
        # currency = "currency" if not symbol else symbol.split("/")[1]
        data = {
            "info": trade,
            "id": id,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp),
            "symbol": symbol,
            "type": order_type,
            "side": side,
            "order": order_id,
            "takerOrMaker": "taker",
            "price": price,
            "amount": amount,
            "cost": price * amount,
            "fee": {
                "currency": None,
                "cost": None,
                "rate": None
            }
        }
        return data

    def parse_my_trades(self, trade):
        return [self.parse_my_trade(i) for i in trade]

    def parse_ohlcv(self, ohlcv, market=None):
        return [
            self.safe_timestamp(ohlcv, 0),
            self.safe_float(ohlcv, 1),
            self.safe_float(ohlcv, 2),
            self.safe_float(ohlcv, 3),
            self.safe_float(ohlcv, 4),
            self.safe_float(ohlcv, 5),
        ]

    def parse_ohlcvs(self,
                     ohlcvs,
                     market=None,
                     timeframe='1',
                     since=None,
                     limit=None):
        ohlcvs = self.to_array(ohlcvs)
        num_ohlcvs = len(ohlcvs)
        result = []
        i = 0
        while i < num_ohlcvs:
            if limit and (len(result) >= limit):
                break
            ohlcv = self.parse_ohlcv(ohlcvs[i], market)
            i = i + 1
            if since and (ohlcv[0] < since):
                continue
            result.append(ohlcv)
        return self.sort_by(result, 0)

    def parse_ticker(self, ticker, market=None):
        # FIXME the timestamp need
        timestamp = self.safe_timestamp(ticker, 'at')
        # ticker = ticker['ticker']
        symbol = ticker.get("reset_symbol")
        if symbol and symbol.endswith("FP"):
            symbol = symbol[:-2]

        if market:
            symbol = market['symbol']
        if "reset_symbol" in ticker:
            del ticker["reset_symbol"]
        last = self.safe_float(ticker, 'c')
        open = self.safe_float(ticker, 'o')
        open = 1 if open == 0 else open
        change = last - open
        percentage = (change / open) * 100
        average = (last + open) / 2
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp // 1000),
            'high': self.safe_float(ticker, 'h'),
            'low': self.safe_float(ticker, 'l'),
            'bid': None,
            'bidVolume': None,
            'ask': None,
            'askVolume': None,
            'vwap': None,
            'open': None,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': percentage,
            'average': average,
            'baseVolume': None,
            'quoteVolume': None,
            'info': ticker,
        }

    def get_time(self, time):
        import datetime
        if isinstance(time, int):
            time = int(time)

            return str(datetime.datetime.fromtimestamp(int(time)))
        return time

    def parse_order(self, order):
        # symbol = None
        # else:
        #     marketId = self.safe_string(order, 'market')
        #     symbol = self.markets_by_id[marketId]['symbol']

        create_time = self.safe_string(order, "createTime")
        timestamp = create_time if create_time else self.parse8601(
            self.safe_string(order, "ts"))
        # timestamp = self.parse8601(self.safe_string(order, 'ts'))
        status = self.parse_order_status(self.safe_string(
            order, 'orderStatus'))
        type = self.safe_string(order, 'orderType')
        side = "buy" if self.safe_string(order, 'side') == 1 else "sell"
        id = self.safe_string(order, 'orderID')
        clientOrderId = self.safe_string(order, 'clOrdID')
        symbol = self.safe_string(order, 'symbol')
        symbol = self.markets_by_id[symbol][
            "symbol"] if self.markets_by_id.get(symbol) else symbol
        if symbol and symbol.endswith("FP"):
            symbol = symbol[:-2]
        average = self.safe_float(order, 'avgPrice')
        price = self.safe_string(order, 'price') or 0
        amount = self.safe_string(order, 'amount')
        filled = self.safe_string(order, 'cumQty') or 0
        if any([price, filled]):
            cost = None
        remaining = self.safe_string(order, 'leavesQty')
        # currency = symbol.split("/")[1] if symbol else "currency"
        currency = None
        return {
            'id':
            id,
            'clientOrderId':
            clientOrderId,
            'timestamp':
            timestamp,
            'datetime':
            self.iso8601(timestamp),
            'lastTradeTimestamp':
            None if not order.get("transactTime") else self.safe_float(
                order, "transactTime"),
            'status':
            status,
            'symbol':
            symbol,
            'type':
            type,
            'side':
            side,
            'price':
            price,
            'amount':
            amount,
            'filled':
            filled,
            "average":
            average,
            'remaining':
            remaining,
            'rejectReason':
            self.safe_string(order, 'rejectReason'),
            'trades': [],
            'info':
            order,
            'cost':
            float(filled) * float(price),
            'fee': {
                "currency": currency,
                "cost": None,
                "rate": None
            },
        }

    def withdraw(self, code, amount, address, tag=None, params={}):
        self.check_address(address)
        self.load_markets()
        currency = self.currency(code)
        # they have XRP but no docs on memo/tag
        request = {
            'currency': currency['id'],
            'sum': amount,
            'address': address,
        }
        response = self.privatePostWithdraw(self.extend(request, params))
        # withdrawal response is undocumented
        return {
            'info': response,
            'id': None,
        }

    def nonce(self):
        return self.milliseconds()

    def encode_params(self, params):
        if 'orders' in params:
            orders = params['orders']
            query = self.urlencode(self.keysort(self.omit(params, 'orders')))
            for i in range(0, len(orders)):
                order = orders[i]
                keys = list(order.keys())
                for k in range(0, len(keys)):
                    key = keys[k]
                    value = order[key]
                    query += '&orders%5B%5D%5B' + key + '%5D=' + str(value)
            return query
        return self.urlencode(self.keysort(params))

    def sign(self,
             path,
             api='public',
             method='GET',
             params={},
             headers=None,
             body=None):

        request = "/" + self.version_1 + '/' + self.implode_params(
            path, params) if params.get(
                "use_v1") else "/" + self.version + '/' + self.implode_params(
                    path, params)

        query = self.omit(params, self.extract_params(path))
        url = self.urls['api'] + request
        if api == 'public':
            if query:
                url += '?' + self.urlencode(query)
        else:
            self.check_required_credentials()
            nonce = self.nonce()
            # nonce = 1603253099063
            if isinstance(nonce, int):
                nonce = str(nonce)
            private_header = {
                'X-ACCESS-KEY': self.apiKey,
                'X-ACCESS-NONCE': nonce,
            }
            suffix = self.urlencode(query)
            if method == "GET":
                if suffix:
                    url += "?" + suffix
                    request += "?" + suffix
                payload = {
                    "nonce": nonce,
                    "verb": method,
                    "path": request,
                    "data": ""
                }
                sign = self.get_sign_form_secret(payload)
                private_header['X-ACCESS-SIGN'] = sign
                headers = self.extend(
                    {'accept': 'application/json;charset=UTF-8'},
                    private_header)
            else:
                payload = {
                    "nonce": nonce,
                    "verb": method,
                    "path": request,
                    "data": self.json(query)
                }

                sign = self.get_sign_form_secret(payload)
                private_header['X-ACCESS-SIGN'] = sign
                body = self.json(query, {'convertArraysToObjects': True})
                headers = self.extend({'Content-Type': 'application/json'},
                                      private_header)

        return {"url": url, "method": method, "body": body, "headers": headers}

    def get_sign_form_secret(self, params):
        # params = {
        #     "nonce": '1603253099063',
        #     "verb": 'POST',
        #     "path": '/v2/spot/orders',
        #     "data": '{"orderType":"LIMIT","symbol":"BTCUSDT","orderQty":0.001,"timeInForce":"GTC","side":"BUY","price":"20"}'
        # }
        message = f"{params.get('nonce')}:{params.get('verb')}{params.get('path')}{params.get('data')}"

        return self.hmac(self.encode(message), self.encode(self.secret))

    def handle_errors(self, code, reason, url, method, headers, body, response,
                      requestHeaders, requestBody):
        if response is None:
            return
        if code == 400:
            error = self.safe_value(response, 'error')
            errorCode = self.safe_string(error, 'code')
            feedback = self.id + ' ' + self.json(response)
            self.throw_exactly_matched_exception(self.exceptions, errorCode,
                                                 feedback)
            # fallback to default error handler

    def check_params(self, params, arr=["spot", "future"]):
        if self.options["defaultType"] not in ["spot", "future"]:
            raise BadRequest("defaultType must be spot or future")
        if params and params.get("type"):
            type = params.get("type")
            if type not in arr:
                raise BadRequest(f"params type must be {arr}")

    def deal_since_limit(self, since, limit):
        result = dict()
        if since:
            result["startDate"] = self.ymd(since)
        if limit:
            result["pageSize"] = limit

        return result

    def pures_type(self):
        return {
            'spot': 'SPTP',
            'future': 'FUTP',
            'otc': 'F2CP',
            'saving': 'VLTP',
        }

    def deal_timeframe(self, timeframe):
        date_scale = self.timeframes.get(timeframe)
        if not date_scale:
            raise BadRequest(f"params type must be {self.timeframes}")
        return date_scale

    def deal_symbol(self, symbol, params):
        self.check_params(params)
        type = params.get("type") or self.options["defaultType"]
        is_spot = type == "spot"

        if not symbol:
            symbol = None

        elif isinstance(symbol, str):
            if symbol.endswith("FP") and params.get("type", -1) == -1:
                is_spot = False
            if is_spot:
                symbol = symbol if not symbol.endswith("FP") else symbol[:-2]
            else:
                symbol = symbol if symbol.endswith("FP") else symbol + "FP"
        elif isinstance(symbol, list):
            new_symbol = list()
            if not params.get("type"):
                is_spot = False

            if is_spot:
                for i in symbol:
                    symbol = i if not i.endswith("FP") else i[:-2]
                    new_symbol.append(symbol)
            else:
                for i in symbol:

                    symbol = i if i.endswith("FP") else i + "FP"
                    new_symbol.append(symbol)
            symbol = new_symbol
        return symbol
